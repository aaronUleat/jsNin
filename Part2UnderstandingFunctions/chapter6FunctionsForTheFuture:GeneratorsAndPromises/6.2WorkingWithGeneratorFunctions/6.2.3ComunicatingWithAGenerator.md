## Comunicando con un generador.

En los ejemplos presentados hasta ahora, usted ha visto como returnar valores multiples desde un generador al usar 
una expresion *yeild*. Pero los generadores son mas poderosas que eso! Tambien podemos enviar datos *a* un generador, 
por lo tanto al conseguir comunicacion bidireccional! Con un generador, podemos producir inmediatamente un resultado,
usar ese resultado para calcular algo mas desde afuera el generador, y despues, cuando quiera que este listo, enviar 
completamente una nueva data de vuelta al generador y resumir su ejecucion. Utilizaremos esta caracteristica para un 
gran efecto al final del capitulo para lidear con codigo asyncronico, pero por ahora, vamos a mantenerlo simple.

### Enviar valores como una funcion Generator
La forma mas facil de enviar datos a un generator es por medio de tratarlo como otra funcion y usar la llamada de la 
funcion como un callback. Vea el siguiente listing.

### Listing 6.8. Enviando datos a un recividor de datos de un generador.
```
function assert(value, description) {
	var result = value ? "pass" : "fail";
	console.log(result + ' - ' +  description);
}
// Un generador puede recivir argumentos estandares, como cualquier otra funcion

function* NinjaGenerator (action) {
	// La magia ocurre. Al hacer el yield al valor, el generador retorna
	// un calculo intermediario. Al llamar al iterador de el siguiente metodo
	// con un argument, enviamos de vuelta al generador
	const imposter = yield ("Hattori " + action);

	// El valor que se envia sobre el siguiente valor de la expresion yielded
	// entonces nuestro impostor es Hanzo.
	assert(imposter === "Hanzo", "El generador ha sido infiltrado");

	yield ("Yoshi ( " + imposter + ") " + action);
}

const ninjaIterator = NinjaGenerator("skulk");
const result1 = ninjaIterator.next();
// Hace trigger de la ejecionn de un generador y chequea que podamos obtener el valor correcto.
assert(result1.value === "Hattori skulk", "Hattori is skulking");

// Envia los datos a un generador como un argumento al sigiuente metodo y chequea
// si el valor es correctamente transferido.
const result2 = ninjaIterator.next("Hanzo");
assert(result2.value === "Yoshi (Hanzo) skulk", "We have an imposter!");
```
Una funcion reciviendo datos no es nada especial; simples funciones mas viejas que lo hace todo el tiempo. Pero 
recuerde, los generadores tienen inmeso poder; ellos pueden ser suspendidos y resumidos. Y se vuelve en torno hacia 
afuera, diferente a funciones standard, cuando resumimos entonces al hacer el request el valor next.

### Utiliznado el metodo next para enviar valores dentro un generador.

En adicion de proveer datos cuando se invoque por primera vez el generador, podemos enviar datos dentro un generador 
al pasar argumentos en el metodo *next()*. En el proceso, podemos despertar al generador de su suspencion y resumir 
su ejecucion. Este valor pasado en el metodo next() es usado por el generador como el valor de toda la expresion 
*yield*, en el cual el generador fue suspendida al corriente, como se muestra en la figura 6.3.

En este ejemplo, tenemos dos llamados al iterador ninjaIterator next(). El primer llamado, ninjaIterator.next(), hace un 
request al primer valor desde el generador. Por que nuestro generador no ha empezado ha ser ejecutado, esta llamada 
inicializa el generador, el cual calcula el valor de la rexpresion "Hattori " + action, hace un yield al valor 
*Hattori skulk*, y suspende a la ejecucion del generador. No hay nada especial sobre esto, hemos hecho algo similar 
muchas veces a lo largo de este capitulo.

Lo mas interesante que esta pasando en el segundo llamado al *ninjaIterator's* con el metodo next(): 
ninjaIterator.next('Hanzo'). A este momento, estamos usando el metodo next() al pasar el dato

![Generators](generatorInitialize.png)

La figura 6.3: El primer llamado al ninjaIterator.next() hace un request un nuevo valor desde el generador, que retorna 
*Hattori skulk* y suspende la ejecucion del el generador en la expresion *yield*. El segundo llamdo *Hanzo* dentro de 
el generador. Este valor va ser usado como el valor de todo la expresion *yield*, y la variable imposter ahora va tener 
el valor de *Hanzo*.