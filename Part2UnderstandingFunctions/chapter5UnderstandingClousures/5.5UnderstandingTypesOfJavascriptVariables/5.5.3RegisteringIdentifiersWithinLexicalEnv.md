### Registering identifiers within lexical environments

Uno de los principios dentras del diseno de Javascript como lenguaje, fue su facilidad de uso. Esa es una de las 
razones por lo cual no especificar *return types*, tipos de parametros, tipos de variables, etc... Y usted ya sabe 
que el codigo en Javascript se ejecuta linea por linea, de una manera directa. Considere lo siguiente:
```
firstRonin = "Kiyokawa";
secondRonin = "Kondo";
```
El valor de *Kiyokawa* es asignado a un identificador *firstRonin*, y despues el valor *Kondo* es asignado al 
identificador *secondRonin*. No hay nada raro con eso cierto? Pero vea el siguiente ejemplo.
 
 ```
 const firstRonin = "Kiyokawa"
 check(firstRonin);
 function check(ronin) {
   assert(ronin === "Kiyokawa", "The roning was checked");
 }
```
En este caso, asignamos el valor de *Kiyokawa* al identificador *firstRonin*, y despues cuando llamamos a la funcion 
*check* con el identificador *firstRonin* como un parametro. Pero mantiene por un segundo -- si el codigo es ejecutado 
linea por linea, deberiamos de poder llamar la funcion *check*? La ejecucion de nuestro programa no a alcanzado su 
declaracion, entonces el Motor de Javascript no deberia saber hacerca de esto.
Pero si *check*, como se muestra en la figura 5.13, usted puede ver que todo esta bien. Javascript no es muy picky 
acerca donde definimos nuestras funciones. Podemos escoger declaraciones de funciones antes o despues de las llamadas. 
Esto no es algo que los desarrolladores deben hacer escando acerca.

#### El proceso de registrar identificadores.
Pero deje la facilidad de un lado, si el codigo es ejecutado linea por linea, como hace el motor de Javascript sabe que 
una funcion *check* es nombrada y existe? Resula que el motor de Javascript hace un poco de trampa, y esa ejecucion 
de Javascript ocurre en dos faces.
La primera fase es activada cuando cualquier ambiente lexico es creado. En esta face, el codigo no fue ejecutado,
pero el motor de Javascript visita y registra todas las variables declaradas y funciones dentro del ambiente lexico 
al corriente. La segunda fase, la ejecucion en javascript, comienza cuando esta se ha completado; el comportamiento
depende en el tipo de variable (let, var, const, y declaracion de funciones) y el tipo de ambiente (global, 
funciones o blques).

El proceso es de la siguiente manera:

1. Si estamos creando un ambiente de una funcion, el implicito identificador *arguments* es creado, con todos los 
parametros de la funcion y los valores de los argumentos. Si estamos lideando con una no-funcion este paso no lo hara.

2. Si estamos creando un ambiente global o el ambiente de una funcion, el codigo al corriente es escaneado ( sin ir 
al cuerpo de otras funciones ), por funciones declaradas ( pero las no-funciones expresiones o funciones arrow). Por 
cada funcion declarada descubierta, una nueva funcion es creada y es ligada a un identificador en el ambiente con el
nombre de la funcion. Si ese nombre de identificador ya existe, su valor es sobreescrito. Si estamos lideando con 
ambientes de bloque este paso es omitido.

3. El codigo al corriente es escaneado por declaracion de variables. En ambiente de funciones y ambientes globales 
todas las variables declaradas con la palabra *var* y definidas fuera de otras funciones (per ellas pueden ser 
declaradas dentro de bloques!) son encontradas, y todas las variables declaradas con las palabras *let* y *const* 
directamente en el bloque al corriente. Por cada variable descubierta, si el identificador no existe en el ambiente, 
el identificador es registrado y su valor es inicializado como undefined. Pero si el identificador existe, se deja 
en el valor.

![Image of Javascript engine steps](engineSteps.png)

b20aa60669c35ecb09227bbfc43a6ff1ea9b2061

